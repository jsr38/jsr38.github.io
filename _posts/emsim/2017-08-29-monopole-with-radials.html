---
layout: page
category : emsim
tagline: "necpp MoM simulation of a monpole with radial ground screen wires"
tags : [mom, necpp, emtheory]
---
<p>
{% include JB/setup %}
</p>

<div id="outline-container-org907f9a0" class="outline-2">
<h2 id="org907f9a0"><span class="section-number-2">1</span> Calculations</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">return</span> <span style="color: #8b2252;">"{0:0.3f}"</span>.<span style="color: #483d8b;">format</span>(3e8 / 118e6 / 4)
</pre>
</div>
<p>
0.636
</p>

<p>
Approximate monopole length in metres.
</p>
</div>
</div>


<div id="outline-container-org4016b1e" class="outline-2">
<h2 id="org4016b1e"><span class="section-number-2">2</span> Perfect ground \(\frac{\lambda}{4}\) monopole</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-python" id="org2929879"><span style="color: #a020f0;">from</span> argparse <span style="color: #a020f0;">import</span> ArgumentParser
<span style="color: #a020f0;">from</span> PyNEC <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">import</span> logging
<span style="color: #a020f0;">import</span> matplotlib.pyplot <span style="color: #a020f0;">as</span> plt
<span style="color: #a020f0;">import</span> mpl_toolkits.mplot3d.axes3d <span style="color: #a020f0;">as</span> axes3d
<span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np
<span style="color: #a020f0;">import</span> os
<span style="color: #a020f0;">import</span> scipy.optimize
<span style="color: #a020f0;">import</span> solid <span style="color: #a020f0;">as</span> sp
<span style="color: #a020f0;">import</span> solid.utils
<span style="color: #a020f0;">import</span> sys
</pre>
</div>

<p>
The following are simulation parameters, fundamental constants and derived parameters used by the simulation.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgcc184e4"><span style="color: #a0522d;">C</span> = 299792458
<span style="color: #8b2252;">"""float: c (ms^1), universal physical constant for speed of light in a vacuum.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">FREQ</span> = 118.2
<span style="color: #8b2252;">"""float: f (s^-1), the excitation frequency applied to the test situation.</span>

<span style="color: #8b2252;">Current value is chosen for the Airband frequency assign to TWR @ SOU</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">BANDWIDTH</span> = 10.0
<span style="color: #8b2252;">"""float: f (s^-1), the bandwidth over which the matching network should operate.</span>

<span style="color: #8b2252;">Current value is arbitrary.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">GROUND_CONDUCTIVITY</span> = 0.002
<span style="color: #8b2252;">"""float: sigma (S), electrical conductivity of ground.</span>

<span style="color: #8b2252;">Current value is something like that experienced around the upper Eastern</span>
<span style="color: #8b2252;">seaboard of the United States.  Real valued conductivity is a function of</span>
<span style="color: #8b2252;">angular frequency (omega) so this value should be altered to something realistic</span>
<span style="color: #8b2252;"> based on our excitation frequency above.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">GROUND_DIELECTRIC</span> = 10
<span style="color: #8b2252;">"""float: epsilon_r (dimensionless), electrical dielectric 'constant' of ground.</span>

<span style="color: #8b2252;">Strictly, this is the real part of the ground relative permittivity.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">BASE</span> = 0.1
<span style="color: #8b2252;">"""float: offset (m) from the ground in the z direction.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">LENGTH</span> = 0.63
<span style="color: #8b2252;">"""float: total length (m) of monopole in z direction.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">N_CONNECTOR_HOLE_PITCH</span> = 0.01824
<span style="color: #8b2252;">"""float: hole pitch (m) of panel mount N connector mount holes</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">CONDUCTIVITY</span> = 1.45e6
<span style="color: #8b2252;">"""float: sigma (S), electrical conductivity of stainless steel.</span>

<span style="color: #8b2252;">Real valued conductivity is a function of angular frequency (omega) so this</span>
<span style="color: #8b2252;">value should be altered to something realistic based on our excitation frequency</span>
<span style="color: #8b2252;"> above.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">R_W</span> = 0.0005
<span style="color: #8b2252;">"""float: r_w, (m), initial wire radius."""</span>

<span style="color: #a0522d;">WAVELENGTH</span> = C / FREQ
<span style="color: #8b2252;">"""float: lambda, (m)"""</span>

<span style="color: #a0522d;">Z0</span> = 50
<span style="color: #8b2252;">"""float: Z_0 (Ohms), feedline characteristic impedance."""</span>

<span style="color: #a0522d;">N_SEGMENTS</span> = 30
<span style="color: #8b2252;">"""int: SEGMENTS , number of segments used in MoM geometry."""</span>

<span style="color: #a0522d;">SEGMENTS</span> = 48
<span style="color: #8b2252;">"""int: SEGMENTS , number of segments used in openscad rendering."""</span>

<span style="color: #a0522d;">DEBUG_LOG</span> = <span style="color: #008b8b;">False</span>
<span style="color: #8b2252;">"""bool: DEBUG_LOG , switch on verbose logging."""</span>

</pre>
</div>

<p>
Some global variables used to track the optimisation path
</p>

<div class="org-src-container">
<pre class="src src-python" id="orge5d0857"><span style="color: #a0522d;">z_path</span> = np.ndarray(shape=(1,0), dtype=<span style="color: #483d8b;">complex</span>)
<span style="color: #a0522d;">gamma_path</span> = np.ndarray(shape=(1,0), dtype=<span style="color: #483d8b;">float</span>)
</pre>
</div>

<p>
This function simply computes \(\Gamma\), the reflection coefficient for a particular antenna scenario given characteristic impedance of the transmission line.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org0fdd0b1"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">reflection_coefficient</span>(z, z0):
    <span style="color: #a020f0;">return</span> np.<span style="color: #483d8b;">abs</span>((z - z0) / (z + z0))

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">vswr</span>(z, z0):
    <span style="color: #a0522d;">Gamma</span> = reflection_coefficient(z, z0)
    <span style="color: #a020f0;">return</span> <span style="color: #483d8b;">float</span>((1 + Gamma) / (1 - Gamma))

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">mismatch</span>(z, z0):
    <span style="color: #a0522d;">Gamma</span> = reflection_coefficient(z, z0)
    <span style="color: #a020f0;">return</span> 1 - Gamma**2
</pre>
</div>

<p>
We construct the antenna geometry, in this case a single wire oriented in the positive z direction with the addition of N radials located equiangularly around the z-axis.  The ground is imperfect having finite conductivity.  We excite the antenna from the first segment (closest to the ground) and compute a radiation pattern and input parameters across a band of frequencies \(\pm 5\)MHz around the design centre frequency.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org0259f2f"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">geometry</span>(base, length, r_w, radial_len,
             radial_offset, n_radials, theta_radial,
             n_segments,
             construct_nec_context=<span style="color: #008b8b;">False</span>,
             construct_solid_geom=<span style="color: #008b8b;">False</span>):
    <span style="color: #a020f0;">if</span> DEBUG_LOG:
        <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"geometry called with {} {} {} {} {} {} {}"</span>
              .<span style="color: #483d8b;">format</span>(base, length, r_w, radial_len,
                      radial_offset, n_radials, theta_radial))

    <span style="color: #b22222;"># </span><span style="color: #b22222;">in case we are constructing neither</span>
    <span style="color: #a0522d;">context</span> = <span style="color: #008b8b;">None</span>
    <span style="color: #a0522d;">solid_geom</span> = <span style="color: #008b8b;">None</span>
    <span style="color: #a0522d;">curr_tag</span> = 1

    <span style="color: #a020f0;">if</span> construct_nec_context:
        <span style="color: #b22222;">#</span><span style="color: #b22222;">creation of a nec context</span>
        <span style="color: #a0522d;">context</span> = nec_context()

        context.set_extended_thin_wire_kernel(<span style="color: #008b8b;">True</span>)
        <span style="color: #b22222;">#</span><span style="color: #b22222;">get the associated geometry</span>
        <span style="color: #a0522d;">geo</span> = context.get_geometry()

    <span style="color: #b22222;">#</span><span style="color: #b22222;">ensure that we meet validity criterion for</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">thin wire aproximation (non-extended thin wire kernel)</span>
    <span style="color: #a020f0;">assert</span> (0.636 / n_segments / r_w) &gt; 8
    <span style="color: #b22222;"># </span><span style="color: #b22222;">TODO: Test the thin wire approximation for the</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">interconnect wires</span>
    <span style="color: #a0522d;">n_interconnect_segments</span> = 1

    <span style="color: #b22222;">#</span><span style="color: #b22222;">add driven element</span>
    <span style="color: #a020f0;">if</span> DEBUG_LOG:
        <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"Add wire {} {} {} "</span>.<span style="color: #483d8b;">format</span>(base, base + length,
                                          r_w))

    <span style="color: #a020f0;">if</span> construct_nec_context:
        geo.wire(curr_tag, n_segments,
                 0.0, 0.0, base,
                 0.0, 0.0, base + length,
                 r_w, 1.0, 1.0)
        <span style="color: #a0522d;">curr_tag</span> += 1
    <span style="color: #a020f0;">if</span> construct_solid_geom:
        <span style="color: #a0522d;">solid_geom</span> = sp.translate([0,0,length/2 + base])(
            sp.cylinder(r=r_w, h=length, center=<span style="color: #008b8b;">True</span>))

    <span style="color: #b22222;">#</span><span style="color: #b22222;">add grounded radials</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">radials are spaced equivalent to holes on a square </span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">with 18.24mm pitch which represents a panel mount N connector</span>
    <span style="color: #a0522d;">delta_theta</span> = 2 * np.pi / n_radials
    <span style="color: #a0522d;">theta_radial_rad</span> = theta_radial * np.pi / 180.0
    <span style="color: #b22222;">#</span><span style="color: #b22222;">equivalent radius for connector mount holes (to handle</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">arbitrary number of radials)</span>
    <span style="color: #a0522d;">connector_radius</span> = N_CONNECTOR_HOLE_PITCH / np.sqrt(2)

    <span style="color: #a020f0;">if</span> DEBUG_LOG:
        <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"delta_theta = {} theta_radial_rad = {} connector_radius = {}"</span>
              .<span style="color: #483d8b;">format</span>(delta_theta, theta_radial_rad, connector_radius))

    <span style="color: #a020f0;">for</span> n <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(n_radials):
        <span style="color: #b22222;">#</span><span style="color: #b22222;">spherical to cartesian transformation</span>
        <span style="color: #b22222;"># </span><span style="color: #b22222;">with theta_radial taken as</span>
        <span style="color: #a0522d;">x_connector_offset</span> = connector_radius * np.cos(delta_theta * n)
        <span style="color: #a0522d;">y_connector_offset</span> = connector_radius * np.sin(delta_theta * n)
        <span style="color: #a0522d;">x</span> = radial_len * np.cos(delta_theta * n) * np.sin(theta_radial_rad) \
            + x_connector_offset
        <span style="color: #a0522d;">y</span> = radial_len * np.sin(delta_theta * n) * np.sin(theta_radial_rad) \
            + y_connector_offset
        <span style="color: #a0522d;">z</span> = radial_len * np.cos(theta_radial_rad)

        <span style="color: #a020f0;">if</span> DEBUG_LOG:
            <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"Add wire {} {} {} -&gt; {} {} {} "</span>
                  .<span style="color: #483d8b;">format</span>(x_connector_offset, y_connector_offset,
                          base - radial_offset,
                          x, y, base - radial_offset - z))

        <span style="color: #a020f0;">if</span> construct_nec_context:
            geo.wire(curr_tag, n_segments,
                     x_connector_offset, y_connector_offset,
                     base - radial_offset,
                     x, y, base - radial_offset - z,
                     r_w, 1.0, 1.0)
            <span style="color: #a0522d;">curr_tag</span> += 1
            <span style="color: #a020f0;">if</span> n &gt; 0:
                geo.wire(curr_tag, n_interconnect_segments,
                         x_connector_offset_prev, y_connector_offset_prev,
                         base - radial_offset,
                         x_connector_offset, y_connector_offset,
                         base - radial_offset,
                         r_w, 1.0, 1.0)
                <span style="color: #a0522d;">curr_tag</span> += 1
            <span style="color: #b22222;"># </span><span style="color: #b22222;">back to the initial radial from the final radial</span>
            <span style="color: #a020f0;">if</span> n == n_radials - 1:
                geo.wire(curr_tag, n_interconnect_segments,
                         x_connector_offset, y_connector_offset,
                         base - radial_offset,
                         connector_radius, 0,
                         base - radial_offset,
                         r_w, 1.0, 1.0)
                <span style="color: #a0522d;">curr_tag</span> += 1


        <span style="color: #a020f0;">if</span> construct_solid_geom:

            <span style="color: #a0522d;">delta_theta_deg</span> = delta_theta * 180 / np.pi
            <span style="color: #a0522d;">solid_geom</span> += sp.translate([x_connector_offset,
                                        y_connector_offset,
                                        base - radial_offset])(
                sp.rotate([0,theta_radial + 90,delta_theta_deg * n])(
                    sp.translate([0,0,radial_len/2])(
                        sp.cylinder(r=r_w, h=radial_len, center=<span style="color: #008b8b;">True</span>))))

            <span style="color: #a020f0;">if</span> n &gt; 0:
                <span style="color: #a0522d;">interconnect_len</span> = \
                    np.sqrt((x_connector_offset_prev     \
                             - x_connector_offset) ** 2  \
                            + (y_connector_offset_prev   \
                               - y_connector_offset) ** 2)
                <span style="color: #a0522d;">delta_y</span> = y_connector_offset - y_connector_offset_prev
                <span style="color: #a0522d;">delta_x</span> = x_connector_offset - x_connector_offset_prev
                <span style="color: #a0522d;">tan_alpha</span> = delta_y / delta_x
                <span style="color: #a0522d;">alpha</span> = np.arctan(tan_alpha)

                <span style="color: #a020f0;">if</span> delta_x &gt; 0:
                    <span style="color: #a0522d;">alpha</span> = alpha + np.pi

                <span style="color: #a0522d;">solid_geom</span> += sp.translate([x_connector_offset,
                                            y_connector_offset,
                                            base - radial_offset])(
                    sp.rotate([0,90,alpha * 180 / np.pi])(
                        sp.translate([0,0,interconnect_len/2])(
                            sp.cylinder(r=r_w, h=interconnect_len, center=<span style="color: #008b8b;">True</span>))))

            <span style="color: #a020f0;">if</span> n == n_radials - 1:

                <span style="color: #a0522d;">tan_alpha</span> = (0.0 - y_connector_offset) /                   \
                            (connector_radius - x_connector_offset)
                <span style="color: #a0522d;">alpha</span> = np.arctan(tan_alpha) + np.pi

                <span style="color: #a0522d;">solid_geom</span> += sp.translate([connector_radius,
                                            0,
                                            base - radial_offset])(
                    sp.rotate([0,90,alpha * 180 / np.pi])(
                        sp.translate([0,0,interconnect_len/2])(
                            sp.cylinder(r=r_w, h=interconnect_len, center=<span style="color: #008b8b;">True</span>))))

        <span style="color: #a0522d;">x_connector_offset_prev</span> = x_connector_offset
        <span style="color: #a0522d;">y_connector_offset_prev</span> = y_connector_offset

    <span style="color: #a020f0;">if</span> construct_nec_context:
        context.geometry_complete(0)

    <span style="color: #a020f0;">return</span> context, solid_geom
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="orge3314c0"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">set_sim_params</span>(context, frequency):
    <span style="color: #b22222;"># </span><span style="color: #b22222;">Group I cards</span>
    context.ld_card(5, 0, 0, 0, CONDUCTIVITY, 0.0, 0.0)
    <span style="color: #b22222;"># </span><span style="color: #b22222;">Don't specify a ground for this one</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">context.gn_card(0, 0, GROUND_DIELECTRIC, GROUND_CONDUCTIVITY,</span>
    <span style="color: #b22222;">#                </span><span style="color: #b22222;">0, 0, 0, 0)</span>

    <span style="color: #b22222;">#</span><span style="color: #b22222;">add a "fr" card to specify the frequency </span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">context.fr_card(0, int(BANDWIDTH), FREQ - BANDWIDTH / 2.0, 1.0)</span>
    context.fr_card(0, 1, frequency, 0.0)

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Group II cards</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">add a "ex" card to specify an excitation</span>
    context.ex_card(0, 0, 1, 0, 0,
                    1.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python" id="org97a158c"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">compute_impedance</span>(context, frequency):

      set_sim_params(context, frequency)
      <span style="color: #b22222;"># </span><span style="color: #b22222;">Group III cards</span>
      context.xq_card(0)

      <span style="color: #b22222;">#</span><span style="color: #b22222;">get the input_parameters</span>
      <span style="color: #a0522d;">ip</span> = context.get_input_parameters(0)
      <span style="color: #a0522d;">z</span> = ip.get_impedance()[0]

      <span style="color: #a020f0;">return</span> z
</pre>
</div>


<div class="org-src-container">
<pre class="src src-python" id="orga6265f2"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">cost_function</span>(x):

    <span style="color: #a0522d;">radial_len</span> = x[2]
    <span style="color: #a0522d;">radial_offset</span> = 0.0
    <span style="color: #a0522d;">n_radials</span> = 4
    <span style="color: #a0522d;">theta_radial</span> = 45.0
    <span style="color: #b22222;">#</span><span style="color: #b22222;">theta_radial = np.exp(x[3])</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">if theta_radial &gt; 80.0:</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">return float('inf')</span>
    <span style="color: #a0522d;">length</span> = x[0]   <span style="color: #b22222;"># </span><span style="color: #b22222;">length &gt;= 0</span>
    <span style="color: #a0522d;">base</span> = x[1]     <span style="color: #b22222;"># </span><span style="color: #b22222;">base &gt;= 0</span>
    <span style="color: #a020f0;">if</span> base &lt; 0 <span style="color: #a020f0;">or</span> length &lt;= 0.1 <span style="color: #a020f0;">or</span> radial_len &lt;= 0.1:
        <span style="color: #a020f0;">return</span> <span style="color: #483d8b;">float</span>(<span style="color: #8b2252;">'inf'</span>)

    <span style="color: #a0522d;">context</span>, <span style="color: #a0522d;">solid_geom</span> = geometry(base, length, R_W, radial_len,
                                   radial_offset, n_radials, theta_radial,
                                   N_SEGMENTS,
                                   construct_nec_context=<span style="color: #008b8b;">True</span>,
                                   construct_solid_geom=<span style="color: #008b8b;">False</span>)

    <span style="color: #a0522d;">z</span> = compute_impedance(context, FREQ)
    <span style="color: #a0522d;">gamma</span> = reflection_coefficient(z, Z0)

    <span style="color: #a020f0;">global</span> z_path, gamma_path
    <span style="color: #a0522d;">z_path</span> = np.append(z_path, z)
    <span style="color: #a0522d;">gamma_path</span> = np.append(gamma_path, gamma)

    <span style="color: #a020f0;">return</span> vswr(z, Z0)
</pre>
</div>

<p>
The main optimisation function below minimises the reflection coefficient with respect to the antenna length.  Unbounded minimisation with a Nelder-Mead simplex algorithm found alleged minima `far' from our desired length at around \(\lambda\) and moving the initial value from \(1.0\)m to \(0.5\) found minima around \(\frac{\lambda}{2}\).  We therefore attempt a bounded minimisation around the \(\frac{\lambda}{4}\) point with \(0.4 \leq x_0 \leq 0.7\)m
</p>


<div class="org-src-container">
<pre class="src src-python" id="org626e54a"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">optimise_antenna</span>():

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Starting value </span>
    <span style="color: #a0522d;">freq</span> = FREQ
    <span style="color: #a0522d;">bounds</span> = [(np.log(0.4), np.log(0.7)),
              (np.log(0.01), np.log(0.02)),
              (np.log(0.4), np.log(0.7)),
              (np.log(15.0), np.log(85.0))]

    <span style="color: #a0522d;">initial_radial_len</span> = 0.6
    <span style="color: #b22222;">#</span><span style="color: #b22222;">initial_theta_radial = np.log(22.0)</span>
    <span style="color: #a0522d;">initial_length</span> = 0.6
    <span style="color: #a0522d;">initial_base</span> = 0.01

    <span style="color: #a0522d;">initial_geom</span> = np.array([initial_length, initial_base, \
                             initial_radial_len])<span style="color: #b22222;">#</span><span style="color: #b22222;">, initial_theta_radial])</span>

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Carry out the minimization</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">result = scipy.optimize.differential_evolution(cost_function, bounds)</span>
    <span style="color: #a0522d;">result</span> = scipy.optimize.minimize(cost_function, initial_geom, \
                                     method=<span style="color: #8b2252;">'Nelder-Mead'</span>)

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'z_path min={} max={}'</span>.<span style="color: #483d8b;">format</span>(np.amin(z_path),
                                        np.amax(z_path)))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'gamma_path min={} max={}'</span>.<span style="color: #483d8b;">format</span>(np.amin(gamma_path),
                                            np.amax(gamma_path)))

    <span style="color: #b22222;">#</span><span style="color: #b22222;">log_length = result.x[0]</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">log_base = result.x[1]</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">length = np.exp(log_length)</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">base = np.exp(log_base)</span>
    <span style="color: #a0522d;">length</span> = result.x[0]
    <span style="color: #a0522d;">base</span> = result.x[1]

    <span style="color: #a0522d;">radial_len</span> = result.x[2]
    <span style="color: #b22222;">#</span><span style="color: #b22222;">radial_len = np.exp(result.x[2])</span>
    <span style="color: #a0522d;">radial_offset</span> = 0.0
    <span style="color: #a0522d;">n_radials</span> = 4
    <span style="color: #b22222;">#</span><span style="color: #b22222;">theta_radial = np.exp(result.x[3])</span>
    <span style="color: #a0522d;">theta_radial</span> = 45.0

    <span style="color: #a020f0;">return</span> base, length, R_W, radial_len, \
        radial_offset, n_radials, theta_radial
</pre>
</div>
</div>
</div>

<div id="outline-container-org2f69aff" class="outline-2">
<h2 id="org2f69aff"><span class="section-number-2">3</span> Compute the radiation pattern for the optimised antenna and plot</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-python" id="orgcb46ebc"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">plot_radiation_pattern</span>(context):

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Group III cards</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">add a "rp" card to specify radiation pattern sampling parameters </span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">and to cause program execution</span>
    context.rp_card(calc_mode=0, n_theta=180, n_phi=720, output_format=0,
                    normalization=0, D=0, A=0,
                    theta0=0.0, delta_theta=0.5, phi0=0.0, delta_phi=0.5,
                    radial_distance=0.0, gain_norm=0.0)

    context.xq_card(0)
    <span style="color: #b22222;">#</span><span style="color: #b22222;">get the radiation_pattern</span>
    <span style="color: #a0522d;">rp</span> = context.get_radiation_pattern(0)

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Gains are in decibels</span>
    <span style="color: #a0522d;">gains_db</span> = rp.get_gain()
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'gains_db.shape = {0}'</span>.<span style="color: #483d8b;">format</span>(gains_db.shape))

    <span style="color: #a0522d;">gains</span> = 10.0**(gains_db / 10.0)
    <span style="color: #a0522d;">thetas</span> = rp.get_theta_angles() * 3.1415 / 180.0
    <span style="color: #a0522d;">phis</span> = rp.get_phi_angles() * 3.1415 / 180.0

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'thetas.shape = {0} [{1},{2}]'</span>
          .<span style="color: #483d8b;">format</span>(thetas.shape, thetas[0], thetas[<span style="color: #483d8b;">len</span>(thetas)-1]))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'phis.shape = {0} [{1},{2}]'</span>
          .<span style="color: #483d8b;">format</span>(phis.shape, phis[0], phis[<span style="color: #483d8b;">len</span>(phis)-1]))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'gains \in [{0},{1}]'</span>.<span style="color: #483d8b;">format</span>(np.amin(gains), np.amax(gains)))
    <span style="color: #a0522d;">fig</span> = plt.figure()

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Plot 2d polar plots</span>
    <span style="color: #a0522d;">ax</span> = fig.add_subplot(2, 2, 1, projection=<span style="color: #8b2252;">'polar'</span>)
    ax.plot(phis, gains[180//4 - 1,:], color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_rmax(1.0)
    ax.set_title(<span style="color: #8b2252;">"Gain at an elevation of 22.5 degrees"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    <span style="color: #a0522d;">ax</span> = fig.add_subplot(2, 2, 2, projection=<span style="color: #8b2252;">'polar'</span>)
    ax.plot(np.concatenate((thetas, np.pi - thetas)),
            np.concatenate((gains[:,0], gains[:,360])),
            color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_rmax(1.5)
    ax.set_thetalim(thetamin=0.0, thetamax=180.0)
    ax.set_thetagrids([0.0, 30.0, 60.0, 90.0, 120.0, 150.0, 180.0])
    ax.set_title(<span style="color: #8b2252;">"Gain sliced through xz-plane"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    <span style="color: #a0522d;">ax</span> = fig.add_subplot(2, 2, 3, projection=<span style="color: #8b2252;">'polar'</span>)
    ax.plot(phis, gains[180//2 - 1,:], color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_rmax(1.0)
    ax.set_title(<span style="color: #8b2252;">"Gain at an elevation of 45 degrees"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    <span style="color: #a0522d;">ax</span> = fig.add_subplot(2, 2, 4, projection=<span style="color: #8b2252;">'polar'</span>)
    ax.plot(np.concatenate((thetas, np.pi - thetas)),
            np.concatenate((gains[:,180], gains[:,540])),
            color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_rmax(1.5)
    ax.set_thetalim(thetamin=0.0, thetamax=180.0)
    ax.set_thetagrids([0.0, 30.0, 60.0, 90.0, 120.0, 150.0, 180.0])
    ax.set_title(<span style="color: #8b2252;">"Gain sliced through yz-plane"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    plt.savefig(<span style="color: #8b2252;">'../images/monopole_radials_polar_plots.png'</span>)
    plt.gcf().clear()


    <span style="color: #b22222;"># </span><span style="color: #b22222;">Plot 3d radiation pattern.</span>
    <span style="color: #a0522d;">R</span> = gains.T
    <span style="color: #a0522d;">THETA</span>, <span style="color: #a0522d;">PHI</span> = np.meshgrid(thetas, phis)
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'THETA.shape = {0}'</span>.<span style="color: #483d8b;">format</span>(THETA.shape))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'PHI.shape = {0}'</span>.<span style="color: #483d8b;">format</span>(PHI.shape))
    <span style="color: #a0522d;">X</span> = R * np.sin(THETA) * np.cos(PHI)
    <span style="color: #a0522d;">Y</span> = R * np.sin(THETA) * np.sin(PHI)
    <span style="color: #a0522d;">Z</span> = R * np.cos(THETA)
    <span style="color: #a0522d;">ax</span> = fig.add_subplot(1, 1, 1, projection=<span style="color: #8b2252;">'3d'</span>)
    <span style="color: #b22222;"># </span><span style="color: #b22222;">Plot the surface.</span>
    ax.plot_surface(X, Y, Z, rstride=1, cstride=1, 
                    cmap=plt.get_cmap(<span style="color: #8b2252;">'jet'</span>), linewidth=0,
                    antialiased=<span style="color: #008b8b;">False</span>, alpha=0.5)
    ax.grid(<span style="color: #008b8b;">True</span>)

    ax.set_title(<span style="color: #8b2252;">"3d gain plot"</span>, va=<span style="color: #8b2252;">'bottom'</span>)
    plt.savefig(<span style="color: #8b2252;">'../images/monopole_radials_3d_gain_plot.png'</span>)
    <span style="color: #b22222;">#</span><span style="color: #b22222;">plt.show()</span>
    plt.gcf().clear()
    plt.close(fig)
</pre>
</div>


<figure>
  <img src="{{ site.url }}/assets/monopole_radials_geom.png" alt="Antenna geometry" width="75%">	
  <figcaption>Antenna geometry</figcaption>
</figure>

<figure>
  <img src="{{ site.url }}/assets/monopole_radials_3d_gain_plot.png" alt="3d radiation pattern plot">	
  <figcaption>3d radiation pattern plot</figcaption>
</figure>


<div id="org8738e2d" class="figure">
<p><img src="../images/monopole_radials_3d_gain_plot.png" alt="monopole_radials_3d_gain_plot.png" />
</p>
<p><span class="figure-number">Figure 1: </span>3d gain plot pattern - radiated</p>
</div>


<p>
And polar plots of gain at various elevation angles
</p>

<figure>
  <img src="{{ site.url }}/assets/monopole_radials_polar_plots.png" alt="Radiation pattern slices">	
  <figcaption>Radiation pattern slice at 45 degrees elevation</figcaption>
</figure>


<div id="org1b3a61c" class="figure">
<p><img src="../images/monopole_radials_polar_plots.png" alt="monopole_radials_polar_plots.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Polar plots of gain pattern at various elevation angles</p>
</div>
</div>
</div>


<div id="outline-container-orgb15870c" class="outline-2">
<h2 id="orgb15870c"><span class="section-number-2">4</span> Compute antenna performance sensitivity to realised length</h2>
</div>

<div id="outline-container-org157270e" class="outline-2">
<h2 id="org157270e"><span class="section-number-2">5</span> Compute antenna performance sensitivity (bandwith) to wire thickness</h2>
</div>

<div id="outline-container-orge13b905" class="outline-2">
<h2 id="orge13b905"><span class="section-number-2">6</span> Compute a suitable bandpass impedance matching network</h2>
<div class="outline-text-2" id="text-6">
<div class="org-src-container">
<pre class="src src-python" id="org6dd1434"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">compute_bp_matching_network</span>(z0, zl):
    <span style="color: #a020f0;">return</span> 0.0
</pre>
</div>
</div>
</div>

<div id="outline-container-orga4e4862" class="outline-2">
<h2 id="orga4e4862"><span class="section-number-2">7</span> Investigate sensitivity to circularly polarised incident radiation</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">
<pre class="src src-python" id="orgb3d8adc"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">main</span>():

    <span style="color: #a0522d;">parser</span> = ArgumentParser(description=<span style="color: #8b2252;">"Optimise monopole and compute matching network."</span>)
    <span style="color: #a0522d;">args</span> = parser.parse_args()

    <span style="color: #b22222;">#</span><span style="color: #b22222;">base, length, r_w, radial_len, \</span>
    <span style="color: #b22222;">#    </span><span style="color: #b22222;">radial_offset, n_radials, theta_radial = optimise_antenna()</span>

    <span style="color: #a0522d;">base</span> = 0.007
    <span style="color: #a0522d;">length</span> = 0.63
    <span style="color: #a0522d;">radial_len</span> = 0.6
    <span style="color: #a0522d;">radial_offset</span> = 0.0
    <span style="color: #a0522d;">n_radials</span> = 3
    <span style="color: #a0522d;">theta_radial</span> = 45.0
    <span style="color: #a0522d;">r_w</span> = R_W

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"\nOptimisation result\n"</span>)
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"final geometry {} {} {} {} {} {} {}"</span>
          .<span style="color: #483d8b;">format</span>(base, length, r_w, radial_len,
                  radial_offset, n_radials, theta_radial))

    <span style="color: #a0522d;">context</span>, <span style="color: #a0522d;">solid_geom</span> = geometry(base, length, r_w, radial_len,
                                   radial_offset, n_radials, theta_radial,
                                   N_SEGMENTS,
                                   construct_nec_context=<span style="color: #008b8b;">True</span>,
                                   construct_solid_geom=<span style="color: #008b8b;">True</span>)

    <span style="color: #a0522d;">out_dir</span> = sys.argv[1] <span style="color: #a020f0;">if</span> <span style="color: #483d8b;">len</span>(sys.argv) &gt; 1 <span style="color: #a020f0;">else</span> os.curdir
    <span style="color: #a0522d;">file_out</span> = os.path.join(out_dir, <span style="color: #8b2252;">'monopoleradials.scad'</span>)
    sp.scad_render_to_file(solid_geom, file_header=<span style="color: #8b2252;">'$fn = {};'</span>.<span style="color: #483d8b;">format</span>(SEGMENTS),
                           include_orig_code=<span style="color: #008b8b;">True</span>)
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"{}: SCAD file written to: \n{}"</span>.<span style="color: #483d8b;">format</span>(__file__, file_out))

    <span style="color: #a0522d;">z</span> = compute_impedance(context, FREQ)

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"Impedance at base={0:.2f}, length={1:.2f}"</span>
          <span style="color: #8b2252;">" : ({2:6.1f},{3:+6.1f}i) Ohms"</span>
          .<span style="color: #483d8b;">format</span>(base, length, z.real, z.imag))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"Reflection coefficient Gamma={0:0.2f}"</span>
          .<span style="color: #483d8b;">format</span>(reflection_coefficient(z, Z0)))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"VSWR @50 ohm ={0:0.2f}"</span>
          .<span style="color: #483d8b;">format</span>(vswr(z, Z0)))

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"z: {0}"</span>.<span style="color: #483d8b;">format</span>(z))

    set_sim_params(context, FREQ)      
    plot_radiation_pattern(context)
    <span style="color: #b22222;">#</span><span style="color: #b22222;">compute_bp_matching_network(Z0, zl)</span>

    <span style="color: #a020f0;">return</span> 0
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell" id="orgfcf1444">python monopoleradials.py 2&gt;&amp;1
true
</pre>
</div>

<pre class="example">
Add wire 0.63 2.63 0.02 
gains_db.shape = (720, 180)
thetas.shape = (720,)
phis.shape = (180,)
THETA.shape = (180, 720)
PHI.shape = (180, 720)

</pre>
</div>
</div>

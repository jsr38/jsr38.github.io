---
layout: page
category : emsim
tagline: "necpp MoM simulation of a monpole with radial ground screen wires"
tags : [mom, necpp, emtheory]
---
<p>
{% include JB/setup %}
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Calculations</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #a020f0;">return</span> <span style="color: #8b2252;">"{0:0.3f}"</span>.<span style="color: #483d8b;">format</span>(3e8 / 118e6 / 4)
</pre>
</div>
<p>
0.636
</p>

<p>
Approximate monopole length in metres.
</p>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Perfect ground \(\frac{\lambda}{4}\) monopole</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-main-imports"><span style="color: #a020f0;">from</span> argparse <span style="color: #a020f0;">import</span> ArgumentParser
<span style="color: #a020f0;">from</span> PyNEC <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">import</span> logging
<span style="color: #a020f0;">import</span> matplotlib.pyplot <span style="color: #a020f0;">as</span> plt
<span style="color: #a020f0;">import</span> mpl_toolkits.mplot3d.axes3d <span style="color: #a020f0;">as</span> axes3d
<span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np
<span style="color: #a020f0;">import</span> os
<span style="color: #a020f0;">import</span> scipy.optimize
<span style="color: #a020f0;">import</span> solid <span style="color: #a020f0;">as</span> sp
<span style="color: #a020f0;">import</span> solid.utils
<span style="color: #a020f0;">import</span> sys
</pre>
</div>

<p>
The following are simulation parameters, fundamental constants and derived parameters used by the simulation.
</p>

<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-constants"><span style="color: #a0522d;">C</span> = 299792458
<span style="color: #8b2252;">"""float: c (ms^1), universal physical constant for speed of light in a vacuum.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">FREQ</span> = 118.2
<span style="color: #8b2252;">"""float: f (s^-1), the excitation frequency applied to the test situation.</span>

<span style="color: #8b2252;">Current value is chosen for the Airband frequency assign to TWR @ SOU</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">BANDWIDTH</span> = 20.0
<span style="color: #8b2252;">"""float: f (s^-1), the bandwidth over which the matching network should operate.</span>

<span style="color: #8b2252;">Current value covers the Airband</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">GROUND_CONDUCTIVITY</span> = 0.002
<span style="color: #8b2252;">"""float: sigma (S), electrical conductivity of ground.</span>

<span style="color: #8b2252;">Current value is something like that experienced around the upper Eastern</span>
<span style="color: #8b2252;">seaboard of the United States.  Real valued conductivity is a function of</span>
<span style="color: #8b2252;">angular frequency (omega) so this value should be altered to something realistic</span>
<span style="color: #8b2252;"> based on our excitation frequency above.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">GROUND_DIELECTRIC</span> = 10
<span style="color: #8b2252;">"""float: epsilon_r (dimensionless), electrical dielectric 'constant' of ground.</span>

<span style="color: #8b2252;">Strictly, this is the real part of the ground relative permittivity.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">BASE</span> = 0.1
<span style="color: #8b2252;">"""float: offset (m) from the ground in the z direction.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">LENGTH</span> = 0.63
<span style="color: #8b2252;">"""float: total length (m) of monopole in z direction.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">N_CONNECTOR_HOLE_PITCH</span> = 0.01824
<span style="color: #8b2252;">"""float: hole pitch (m) of panel mount N connector mount holes</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">CONDUCTIVITY_SS</span> = 1.45e6
<span style="color: #8b2252;">"""float: sigma (S), electrical conductivity of stainless steel.</span>

<span style="color: #8b2252;">Real part of admittivity is conductivity and is a function of angular frequency</span>
<span style="color: #8b2252;"> (omega) so this value should be altered to something realistic based on our </span>
<span style="color: #8b2252;">excitation frequency above.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">CONDUCTIVITY_CU</span> = 5.96e7
<span style="color: #8b2252;">"""float: sigma (S), electrical conductivity of copper.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">CONDUCTIVITY_AL</span> = 3.5e7
<span style="color: #8b2252;">"""float: sigma (S), electrical conductivity of stainless steel.</span>

<span style="color: #8b2252;">"""</span>

<span style="color: #a0522d;">R_W</span> = 0.0005
<span style="color: #8b2252;">"""float: r_w, (m), initial wire radius."""</span>

<span style="color: #a0522d;">WAVELENGTH</span> = C / FREQ
<span style="color: #8b2252;">"""float: lambda, (m)"""</span>

<span style="color: #a0522d;">Z0</span> = 50
<span style="color: #8b2252;">"""float: Z_0 (Ohms), feedline characteristic impedance."""</span>

<span style="color: #a0522d;">N_SEGMENTS</span> = 30
<span style="color: #8b2252;">"""int: SEGMENTS , number of segments used in MoM geometry."""</span>

<span style="color: #a0522d;">SEGMENTS</span> = 48
<span style="color: #8b2252;">"""int: SEGMENTS , number of segments used in openscad rendering."""</span>

<span style="color: #a0522d;">SIGMA_L</span> = 0.01
<span style="color: #8b2252;">"""float: SIGMA_L , construction uncertainty for wire lengths."""</span>

<span style="color: #a0522d;">DEBUG_LOG</span> = <span style="color: #008b8b;">False</span>
<span style="color: #8b2252;">"""bool: DEBUG_LOG , switch on verbose logging."""</span>
</pre>
</div>

<p>
Some global variables used to track the optimisation path
</p>

<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-globals"><span style="color: #a0522d;">z_path</span> = np.ndarray(shape=(1,0), dtype=<span style="color: #483d8b;">complex</span>)
<span style="color: #a0522d;">gamma_path</span> = np.ndarray(shape=(1,0), dtype=<span style="color: #483d8b;">float</span>)
</pre>
</div>

<p>
This function simply computes \(\Gamma\), the reflection coefficient for a particular antenna scenario given characteristic impedance of the transmission line.
</p>

<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-antenna-util"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">reflection_coefficient</span>(z, z0):
    <span style="color: #a020f0;">return</span> np.<span style="color: #483d8b;">abs</span>((z - z0) / (z + z0))

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">vswr</span>(z, z0):
    <span style="color: #a0522d;">Gamma</span> = reflection_coefficient(z, z0)
    <span style="color: #a020f0;">return</span> <span style="color: #483d8b;">float</span>((1 + Gamma) / (1 - Gamma))

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">mismatch</span>(z, z0):
    <span style="color: #a0522d;">Gamma</span> = reflection_coefficient(z, z0)
    <span style="color: #a020f0;">return</span> 1 - Gamma**2
</pre>
</div>

<p>
We construct the antenna geometry, in this case a single wire oriented in the positive z direction with the addition of N radials located equiangularly around the z-axis.  We consider the antenna's response to excitation in the absence of a ground plane.  We excite the antenna from the first segment (closest to the ground) and compute a radiation pattern and input parameters across a band of frequencies \(\pm 5\)MHz around the design centre frequency.
</p>

<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-geometry"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">geometry</span>(base, length, r_w, radial_len,
             radial_offset, n_radials, theta_radial,
             n_segments,
             construct_nec_context=<span style="color: #008b8b;">True</span>,
             construct_solid_geom=<span style="color: #008b8b;">False</span>):
    <span style="color: #a020f0;">if</span> DEBUG_LOG:
        <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"geometry called with {} {} {} {} {} {} {}"</span>
              .<span style="color: #483d8b;">format</span>(base, length, r_w, radial_len,
                      radial_offset, n_radials, theta_radial))

    <span style="color: #b22222;"># </span><span style="color: #b22222;">in case we are constructing neither</span>
    <span style="color: #a0522d;">context</span> = <span style="color: #008b8b;">None</span>
    <span style="color: #a0522d;">solid_geom</span> = <span style="color: #008b8b;">None</span>
    <span style="color: #a0522d;">curr_tag</span> = 1

    <span style="color: #a020f0;">if</span> construct_nec_context:
        <span style="color: #b22222;">#</span><span style="color: #b22222;">creation of a nec context</span>
        <span style="color: #a0522d;">context</span> = nec_context()

        context.set_extended_thin_wire_kernel(<span style="color: #008b8b;">True</span>)
        <span style="color: #b22222;">#</span><span style="color: #b22222;">get the associated geometry</span>
        <span style="color: #a0522d;">geo</span> = context.get_geometry()

    <span style="color: #b22222;">#</span><span style="color: #b22222;">ensure that we meet validity criterion for</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">thin wire aproximation (non-extended thin wire kernel)</span>
    <span style="color: #a020f0;">assert</span> (0.636 / n_segments / r_w) &gt; 8
    <span style="color: #b22222;"># </span><span style="color: #b22222;">TODO: Test the thin wire approximation for the</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">interconnect wires</span>
    <span style="color: #a0522d;">n_interconnect_segments</span> = 1

    <span style="color: #b22222;">#</span><span style="color: #b22222;">add driven element</span>
    <span style="color: #a020f0;">if</span> DEBUG_LOG:
        <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"Add wire {} {} {} "</span>.<span style="color: #483d8b;">format</span>(base, base + length,
                                          r_w))

    <span style="color: #a020f0;">if</span> construct_nec_context:
        geo.wire(curr_tag, n_segments,
                 0.0, 0.0, base,
                 0.0, 0.0, base + length,
                 r_w, 1.0, 1.0)
        <span style="color: #a0522d;">curr_tag</span> += 1
    <span style="color: #a020f0;">if</span> construct_solid_geom:
        <span style="color: #a0522d;">solid_geom</span> = sp.translate([0,0,length/2 + base])(
            sp.cylinder(r=r_w, h=length, center=<span style="color: #008b8b;">True</span>))

    <span style="color: #b22222;">#</span><span style="color: #b22222;">add radials</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">radials are spaced equivalent to holes on a square </span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">with 18.24mm pitch which represents a panel mount N connector</span>
    <span style="color: #a0522d;">delta_theta</span> = 2 * np.pi / n_radials
    <span style="color: #a0522d;">theta_radial_rad</span> = theta_radial * np.pi / 180.0
    <span style="color: #b22222;">#</span><span style="color: #b22222;">equivalent radius for connector mount holes (to handle</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">arbitrary number of radials)</span>
    <span style="color: #a0522d;">connector_radius</span> = N_CONNECTOR_HOLE_PITCH / np.sqrt(2)

    <span style="color: #a020f0;">if</span> DEBUG_LOG:
        <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"delta_theta = {} theta_radial_rad = {} connector_radius = {}"</span>
              .<span style="color: #483d8b;">format</span>(delta_theta, theta_radial_rad, connector_radius))

    <span style="color: #a020f0;">for</span> n <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(n_radials):
        <span style="color: #b22222;">#</span><span style="color: #b22222;">spherical to cartesian transformation</span>
        <span style="color: #b22222;"># </span><span style="color: #b22222;">with theta_radial taken as</span>
        <span style="color: #a0522d;">x_connector_offset</span> = connector_radius * np.cos(delta_theta * n)
        <span style="color: #a0522d;">y_connector_offset</span> = connector_radius * np.sin(delta_theta * n)
        <span style="color: #a0522d;">x</span> = radial_len * np.cos(delta_theta * n) * np.sin(theta_radial_rad) \
            + x_connector_offset
        <span style="color: #a0522d;">y</span> = radial_len * np.sin(delta_theta * n) * np.sin(theta_radial_rad) \
            + y_connector_offset
        <span style="color: #a0522d;">z</span> = radial_len * np.cos(theta_radial_rad)

        <span style="color: #a020f0;">if</span> DEBUG_LOG:
            <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"Add wire {} {} {} -&gt; {} {} {} "</span>
                  .<span style="color: #483d8b;">format</span>(x_connector_offset, y_connector_offset,
                          base - radial_offset,
                          x, y, base - radial_offset - z))

        <span style="color: #a020f0;">if</span> construct_nec_context:
            geo.wire(curr_tag, n_segments,
                     x_connector_offset, y_connector_offset,
                     base - radial_offset,
                     x, y, base - radial_offset - z,
                     r_w, 1.0, 1.0)
            <span style="color: #a0522d;">curr_tag</span> += 1
            <span style="color: #a020f0;">if</span> n &gt; 0:
                <span style="color: #b22222;"># </span><span style="color: #b22222;">wire from previous to current radial</span>
                geo.wire(curr_tag, n_interconnect_segments,
                         x_connector_offset_prev, y_connector_offset_prev,
                         base - radial_offset,
                         x_connector_offset, y_connector_offset,
                         base - radial_offset,
                         r_w, 1.0, 1.0)
                <span style="color: #a0522d;">curr_tag</span> += 1
                <span style="color: #b22222;"># </span><span style="color: #b22222;">wire from driven element to current radial</span>
                geo.wire(curr_tag, n_interconnect_segments,
                         0.0, 0.0,
                         base,
                         x_connector_offset, y_connector_offset,
                         base - radial_offset,
                         r_w, 1.0, 1.0)
                <span style="color: #a0522d;">curr_tag</span> += 1                
            <span style="color: #b22222;"># </span><span style="color: #b22222;">back to the initial radial from the final radial</span>
            <span style="color: #a020f0;">if</span> n == n_radials - 1:
                geo.wire(curr_tag, n_interconnect_segments,
                         x_connector_offset, y_connector_offset,
                         base - radial_offset,
                         connector_radius, 0,
                         base - radial_offset,
                         r_w, 1.0, 1.0)
                <span style="color: #a0522d;">curr_tag</span> += 1


        <span style="color: #a020f0;">if</span> construct_solid_geom:

            <span style="color: #a0522d;">delta_theta_deg</span> = delta_theta * 180 / np.pi
            <span style="color: #a0522d;">solid_geom</span> += sp.translate([x_connector_offset,
                                        y_connector_offset,
                                        base - radial_offset])(
                sp.rotate([0,theta_radial + 90,delta_theta_deg * n])(
                    sp.translate([0,0,radial_len/2])(
                        sp.cylinder(r=r_w, h=radial_len, center=<span style="color: #008b8b;">True</span>))))

            <span style="color: #a020f0;">if</span> n &gt; 0:
                <span style="color: #b22222;"># </span><span style="color: #b22222;">wire from previous to current radial</span>
                <span style="color: #a0522d;">interconnect_len</span> = \
                    np.sqrt((x_connector_offset_prev     \
                             - x_connector_offset) ** 2  \
                            + (y_connector_offset_prev   \
                               - y_connector_offset) ** 2)
                <span style="color: #a0522d;">delta_y</span> = y_connector_offset - y_connector_offset_prev
                <span style="color: #a0522d;">delta_x</span> = x_connector_offset - x_connector_offset_prev
                <span style="color: #a0522d;">tan_alpha</span> = delta_y / delta_x
                <span style="color: #a0522d;">alpha</span> = np.arctan(tan_alpha)

                <span style="color: #a020f0;">if</span> delta_x &gt; 0:
                    <span style="color: #a0522d;">alpha</span> = alpha + np.pi

                <span style="color: #a0522d;">solid_geom</span> += sp.translate([x_connector_offset,
                                            y_connector_offset,
                                            base - radial_offset])(
                    sp.rotate([0,90,alpha * 180 / np.pi])(
                        sp.translate([0,0,interconnect_len/2])(
                            sp.cylinder(r=r_w, h=interconnect_len,
                                        center=<span style="color: #008b8b;">True</span>))))

            <span style="color: #a020f0;">if</span> n == n_radials - 1:
                <span style="color: #b22222;"># </span><span style="color: #b22222;">back to the initial radial from the final radial</span>
                <span style="color: #a0522d;">tan_alpha</span> = (0.0 - y_connector_offset) /                   \
                            (connector_radius - x_connector_offset)
                <span style="color: #a0522d;">alpha</span> = np.arctan(tan_alpha) + np.pi

                <span style="color: #a0522d;">solid_geom</span> += sp.translate([connector_radius,
                                            0,
                                            base - radial_offset])(
                    sp.rotate([0,90,alpha * 180 / np.pi])(
                        sp.translate([0,0,interconnect_len/2])(
                            sp.cylinder(r=r_w, h=interconnect_len,
                                        center=<span style="color: #008b8b;">True</span>))))

            <span style="color: #b22222;"># </span><span style="color: #b22222;">wire from driven element to current radial</span>
            <span style="color: #a0522d;">driven_to_radial_len</span> = \
                np.sqrt(x_connector_offset ** 2            \
                        + y_connector_offset ** 2          \
                        + radial_offset ** 2)
            <span style="color: #a0522d;">solid_geom</span> += sp.translate([0.0,
                                        0.0,
                                        base])(
                sp.rotate([0,90,delta_theta_deg * n])(
                    sp.translate([0,0,driven_to_radial_len/2])(
                        sp.cylinder(r=r_w, h=driven_to_radial_len,
                                    center=<span style="color: #008b8b;">True</span>))))


        <span style="color: #a0522d;">x_connector_offset_prev</span> = x_connector_offset
        <span style="color: #a0522d;">y_connector_offset_prev</span> = y_connector_offset

    <span style="color: #a020f0;">if</span> construct_nec_context:
        <span style="color: #b22222;"># </span><span style="color: #b22222;">Group I cards</span>
        context.ld_card(5, 0, 0, 0, CONDUCTIVITY_AL, 0.0, 0.0)
        <span style="color: #b22222;"># </span><span style="color: #b22222;">Don't specify a ground for this one</span>
        <span style="color: #b22222;">#</span><span style="color: #b22222;">context.gn_card(0, 0, GROUND_DIELECTRIC, GROUND_CONDUCTIVITY,</span>
        <span style="color: #b22222;">#                </span><span style="color: #b22222;">0, 0, 0, 0)</span>
        context.geometry_complete(0)

    <span style="color: #a020f0;">return</span> context, solid_geom
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-setsimparams"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">set_frequencies_linear</span>(context, start_frequency, stop_frequency,
                           count=<span style="color: #008b8b;">None</span>, step_size=<span style="color: #008b8b;">None</span>):
    <span style="color: #8b2252;">""" If start_frequency does not equal stop_frequency, either count or </span>
<span style="color: #8b2252;">      step should be specified. The other parameter will be automatically deduced """</span>

    <span style="color: #a020f0;">if</span> start_frequency == stop_frequency:
        <span style="color: #a0522d;">step_size</span> = 0
        <span style="color: #a0522d;">count</span> = 1
    <span style="color: #a020f0;">else</span>:
        <span style="color: #b22222;"># </span><span style="color: #b22222;">TODO: add some asserts</span>
        <span style="color: #a020f0;">if</span> count <span style="color: #a020f0;">is</span> <span style="color: #a020f0;">not</span> <span style="color: #008b8b;">None</span>:
            <span style="color: #a0522d;">step_size</span> = (stop_frequency - start_frequency) / count
        <span style="color: #a020f0;">else</span>:
            <span style="color: #a0522d;">count</span> = (stop_frequency - start_frequency) / step_size

    <span style="color: #b22222;"># </span><span style="color: #b22222;">TODO, what if we don't have nice divisibility here</span>
    <span style="color: #a0522d;">count</span> = <span style="color: #483d8b;">int</span>(count)

    <span style="color: #a0522d;">ifrq_linear_step</span> = 0

    context.fr_card(ifrq_linear_step, count, start_frequency, step_size)


<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">set_frequency</span>(context, frequency):
    set_frequencies_linear(context, frequency, frequency)

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">set_excitation</span>(context):
    <span style="color: #b22222;"># </span><span style="color: #b22222;">Group II cards</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">add a "ex" card to specify an excitation</span>
    context.ex_card(0, 0, 1, 0, 0,
                    1.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-impedance"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">compute_impedance</span>(context, frequency):

      set_frequency(context, frequency)
      set_excitation(context)
      <span style="color: #b22222;"># </span><span style="color: #b22222;">Group III cards</span>
      context.xq_card(0)

      <span style="color: #b22222;">#</span><span style="color: #b22222;">get the input_parameters</span>
      <span style="color: #a0522d;">ip</span> = context.get_input_parameters(0)
      <span style="color: #a0522d;">z</span> = ip.get_impedance()[0]

      <span style="color: #a020f0;">return</span> z
</pre>
</div>


<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-cost-function"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">cost_function</span>(x):

    <span style="color: #a0522d;">radial_len</span> = x[2]
    <span style="color: #a0522d;">radial_offset</span> = 0.0
    <span style="color: #a0522d;">n_radials</span> = 4
    <span style="color: #a0522d;">theta_radial</span> = x[3]
    <span style="color: #a020f0;">if</span> theta_radial &gt; 80.0 <span style="color: #a020f0;">or</span> theta_radial &lt; 0.0:
        <span style="color: #a020f0;">return</span> <span style="color: #483d8b;">float</span>(<span style="color: #8b2252;">'inf'</span>)

    <span style="color: #a0522d;">length</span> = x[0]   <span style="color: #b22222;"># </span><span style="color: #b22222;">length &gt;= 0</span>
    <span style="color: #a0522d;">base</span> = x[1]     <span style="color: #b22222;"># </span><span style="color: #b22222;">base &gt;= 0</span>
    <span style="color: #a020f0;">if</span> base &lt; 0 <span style="color: #a020f0;">or</span> length &lt;= 0.1 <span style="color: #a020f0;">or</span> radial_len &lt;= 0.1:
        <span style="color: #a020f0;">return</span> <span style="color: #483d8b;">float</span>(<span style="color: #8b2252;">'inf'</span>)

    <span style="color: #a0522d;">context</span>, <span style="color: #a0522d;">solid_geom</span> = geometry(base, length, R_W, radial_len,
                                   radial_offset, n_radials, theta_radial,
                                   N_SEGMENTS,
                                   construct_nec_context=<span style="color: #008b8b;">True</span>,
                                   construct_solid_geom=<span style="color: #008b8b;">False</span>)

    <span style="color: #a0522d;">z</span> = compute_impedance(context, FREQ)
    <span style="color: #a0522d;">gamma</span> = reflection_coefficient(z, Z0)

    <span style="color: #a020f0;">global</span> z_path, gamma_path
    <span style="color: #a0522d;">z_path</span> = np.append(z_path, z)
    <span style="color: #a0522d;">gamma_path</span> = np.append(gamma_path, gamma)

    <span style="color: #a020f0;">return</span> vswr(z, Z0)
</pre>
</div>

<p>
The main optimisation function below attempts to minimise the reflection coefficient with respect to the driven element length, the length of the radial elements and the angle the radials make with the xy-plane.  Unbounded minimisation with a Nelder-Mead simplex algorithm found an alleged minimum of \(\Gamma = 0.02\) with corresponding imput impedance of \(Z = 52.5 - 0.5i \Omega\).
</p>


<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-optimise-antenna"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">optimise_antenna</span>():

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Starting value </span>
    <span style="color: #a0522d;">freq</span> = FREQ
    <span style="color: #a0522d;">bounds</span> = [(np.log(0.4), np.log(0.7)),
              (np.log(0.01), np.log(0.02)),
              (np.log(0.4), np.log(0.7)),
              (np.log(15.0), np.log(85.0))]

    <span style="color: #a0522d;">initial_radial_len</span> = 0.6
    <span style="color: #a0522d;">initial_theta_radial</span> = 22.0
    <span style="color: #a0522d;">initial_length</span> = 0.6
    <span style="color: #a0522d;">initial_base</span> = 0.01

    <span style="color: #a0522d;">initial_geom</span> = np.array([initial_length, initial_base, \
                             initial_radial_len, initial_theta_radial])

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Carry out the minimization</span>
    <span style="color: #a0522d;">result</span> = scipy.optimize.minimize(cost_function, initial_geom, \
                                     method=<span style="color: #8b2252;">'Nelder-Mead'</span>)

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'z_path min={} max={}'</span>.<span style="color: #483d8b;">format</span>(np.amin(z_path),
                                        np.amax(z_path)))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'gamma_path min={} max={}'</span>.<span style="color: #483d8b;">format</span>(np.amin(gamma_path),
                                            np.amax(gamma_path)))

    <span style="color: #a0522d;">length</span> = result.x[0]
    <span style="color: #a0522d;">base</span> = result.x[1]

    <span style="color: #a0522d;">radial_len</span> = result.x[2]
    <span style="color: #a0522d;">radial_offset</span> = 0.0
    <span style="color: #a0522d;">n_radials</span> = 4
    <span style="color: #a0522d;">theta_radial</span> = result.x[3]

    <span style="color: #a020f0;">return</span> base, length, R_W, radial_len, \
        radial_offset, n_radials, theta_radial
</pre>
</div>

<p>
The geometry yielding these simulated parameters is shown in figure <a href="#monpole_radials_geom">monpole_radials_geom</a> .  It has a driven element length of \(l_d = 0.701\)m and radials of length \(l_r = 0.348 \)m that make angle \(\theta _r = 46.86^{\circ} \) with the xy-plane.
</p>

<figure>
  <img src="{{ site.url }}/assets/monopole_radials_geom.png" alt="Antenna geometry" width="75%">        
  <figcaption>Antenna geometry</figcaption>
</figure>


<div id="fig:monopole_radials_geom" class="figure">
<p><img src="../images/monopole_radials_geom.png" alt="monopole_radials_geom.png" />
</p>
<p><span class="figure-number">Figure 1:</span> Optimised antenna geometry</p>
</div>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Compute the radiation pattern for the optimised antenna and plot</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-plot-radiation-pattern"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">plot_radiation_pattern</span>(context):

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Group III cards</span>
    <span style="color: #b22222;">#</span><span style="color: #b22222;">add a "rp" card to specify radiation pattern sampling parameters </span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">and to cause program execution</span>
    context.rp_card(calc_mode=0, n_theta=180, n_phi=720, output_format=0,
                    normalization=0, D=0, A=0,
                    theta0=0.0, delta_theta=0.5, phi0=0.0, delta_phi=0.5,
                    radial_distance=0.0, gain_norm=0.0)

    context.xq_card(0)
    <span style="color: #b22222;">#</span><span style="color: #b22222;">get the radiation_pattern</span>
    <span style="color: #a0522d;">rp</span> = context.get_radiation_pattern(0)

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Gains are in decibels</span>
    <span style="color: #a0522d;">gains_db</span> = rp.get_gain()
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'gains_db.shape = {0}'</span>.<span style="color: #483d8b;">format</span>(gains_db.shape))

    <span style="color: #a0522d;">gains</span> = 10.0**(gains_db / 10.0)
    <span style="color: #a0522d;">thetas</span> = rp.get_theta_angles() * 3.1415 / 180.0
    <span style="color: #a0522d;">phis</span> = rp.get_phi_angles() * 3.1415 / 180.0

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'thetas.shape = {0} [{1},{2}]'</span>
          .<span style="color: #483d8b;">format</span>(thetas.shape, thetas[0], thetas[<span style="color: #483d8b;">len</span>(thetas)-1]))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'phis.shape = {0} [{1},{2}]'</span>
          .<span style="color: #483d8b;">format</span>(phis.shape, phis[0], phis[<span style="color: #483d8b;">len</span>(phis)-1]))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'gains \in [{0},{1}]'</span>.<span style="color: #483d8b;">format</span>(np.amin(gains), np.amax(gains)))
    <span style="color: #a0522d;">fig</span> = plt.figure()

    <span style="color: #b22222;"># </span><span style="color: #b22222;">Plot 2d polar plots</span>
    <span style="color: #a0522d;">ax</span> = fig.add_subplot(2, 2, 1, projection=<span style="color: #8b2252;">'polar'</span>)
    ax.plot(phis, gains[180//4 - 1,:], color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_rmax(1.0)
    ax.set_title(<span style="color: #8b2252;">"Gain at an elevation of 22.5 degrees"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    <span style="color: #a0522d;">ax</span> = fig.add_subplot(2, 2, 2, projection=<span style="color: #8b2252;">'polar'</span>)
    ax.plot(np.concatenate((thetas, np.pi - thetas)),
            np.concatenate((gains[:,0], gains[:,360])),
            color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_rmax(1.5)
    ax.set_thetalim(thetamin=0.0, thetamax=180.0)
    ax.set_thetagrids([0.0, 30.0, 60.0, 90.0, 120.0, 150.0, 180.0])
    ax.set_title(<span style="color: #8b2252;">"Gain sliced through xz-plane"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    <span style="color: #a0522d;">ax</span> = fig.add_subplot(2, 2, 3, projection=<span style="color: #8b2252;">'polar'</span>)
    ax.plot(phis, gains[180//2 - 1,:], color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_rmax(1.0)
    ax.set_title(<span style="color: #8b2252;">"Gain at an elevation of 45 degrees"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    <span style="color: #a0522d;">ax</span> = fig.add_subplot(2, 2, 4, projection=<span style="color: #8b2252;">'polar'</span>)
    ax.plot(np.concatenate((thetas, np.pi - thetas)),
            np.concatenate((gains[:,180], gains[:,540])),
            color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_rmax(1.5)
    ax.set_thetalim(thetamin=0.0, thetamax=180.0)
    ax.set_thetagrids([0.0, 30.0, 60.0, 90.0, 120.0, 150.0, 180.0])
    ax.set_title(<span style="color: #8b2252;">"Gain sliced through yz-plane"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    plt.savefig(<span style="color: #8b2252;">'../images/monopole_radials_polar_plots.png'</span>)
    plt.gcf().clear()


    <span style="color: #b22222;"># </span><span style="color: #b22222;">Plot 3d radiation pattern.</span>
    <span style="color: #a0522d;">R</span> = gains.T
    <span style="color: #a0522d;">THETA</span>, <span style="color: #a0522d;">PHI</span> = np.meshgrid(thetas, phis)
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'THETA.shape = {0}'</span>.<span style="color: #483d8b;">format</span>(THETA.shape))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">'PHI.shape = {0}'</span>.<span style="color: #483d8b;">format</span>(PHI.shape))
    <span style="color: #a0522d;">X</span> = R * np.sin(THETA) * np.cos(PHI)
    <span style="color: #a0522d;">Y</span> = R * np.sin(THETA) * np.sin(PHI)
    <span style="color: #a0522d;">Z</span> = R * np.cos(THETA)
    <span style="color: #a0522d;">ax</span> = fig.add_subplot(1, 1, 1, projection=<span style="color: #8b2252;">'3d'</span>)
    <span style="color: #b22222;"># </span><span style="color: #b22222;">Plot the surface.</span>
    ax.plot_surface(X, Y, Z, rstride=1, cstride=1, 
                    cmap=plt.get_cmap(<span style="color: #8b2252;">'jet'</span>), linewidth=0,
                    antialiased=<span style="color: #008b8b;">False</span>, alpha=0.5)
    ax.grid(<span style="color: #008b8b;">True</span>)

    ax.set_title(<span style="color: #8b2252;">"3d gain plot"</span>, va=<span style="color: #8b2252;">'bottom'</span>)
    plt.savefig(<span style="color: #8b2252;">'../images/monopole_radials_3d_gain_plot.png'</span>)
    <span style="color: #b22222;">#</span><span style="color: #b22222;">plt.show()</span>
    plt.gcf().clear()
    plt.close(fig)
</pre>
</div>


<figure>
  <img src="{{ site.url }}/assets/monopole_radials_3d_gain_plot.png" alt="3d radiation pattern plot">   
  <figcaption>3d radiation pattern plot</figcaption>
</figure>


<div id="fig:monopole_radials_3d_gain_plot" class="figure">
<p><img src="../images/monopole_radials_3d_gain_plot.png" alt="monopole_radials_3d_gain_plot.png" />
</p>
<p><span class="figure-number">Figure 2:</span> 3d gain plot pattern - radiated</p>
</div>


<p>
And polar plots of gain at various elevation angles
</p>

<figure>
  <img src="{{ site.url }}/assets/monopole_radials_polar_plots.png" alt="Radiation pattern slices">     
  <figcaption>Radiation pattern slice at 45 degrees elevation</figcaption>
</figure>


<div id="fig:monopole_radials_polar_plots" class="figure">
<p><img src="../images/monopole_radials_polar_plots.png" alt="monopole_radials_polar_plots.png" />
</p>
<p><span class="figure-number">Figure 3:</span> Polar plots of gain pattern at various elevation angles</p>
</div>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> VSWR as a function of frequency</h2>
<div class="outline-text-2" id="text-4">
<p>
For our optimised antenna, how does the effective match to a \(50 \Omega \) load vary with frequency?
</p>

<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-compute-vswr"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">compute_vswr</span>(context):

    <span style="color: #a0522d;">count</span> = 50
    set_frequencies_linear(context, FREQ - BANDWIDTH/2.0,
                           FREQ + BANDWIDTH/2.0, count=count)
    set_excitation(context)
    context.xq_card(0) <span style="color: #b22222;"># </span><span style="color: #b22222;">Execute simulation</span>

    <span style="color: #a0522d;">freqs</span> = []
    <span style="color: #a0522d;">vswrs</span> = []
    <span style="color: #a020f0;">for</span> idx <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(0, count):
        <span style="color: #a0522d;">ipt</span> = context.get_input_parameters(idx)
        <span style="color: #a0522d;">z</span> = ipt.get_impedance()

        freqs.append(ipt.get_frequency() / 1000000)
        vswrs.append(vswr(z, Z0))

    <span style="color: #a020f0;">return</span> freqs, vswrs
</pre>
</div>

<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-plot-vswr"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">plot_vswr</span>(freqs, vswrs):

    <span style="color: #a0522d;">fig</span> = plt.figure()
    <span style="color: #b22222;"># </span><span style="color: #b22222;">Plot cartesian, linear scale</span>
    <span style="color: #a0522d;">ax</span> = fig.add_subplot(1, 1, 1, projection=<span style="color: #8b2252;">'rectilinear'</span>)
    ax.plot(freqs, vswrs, color=<span style="color: #8b2252;">'r'</span>, linewidth=3)
    ax.grid(<span style="color: #008b8b;">True</span>)
    ax.set_xlabel(<span style="color: #8b2252;">"Frequency (MHz)"</span>)
    ax.set_ylabel(<span style="color: #8b2252;">"VSWR"</span>)
    ax.set_title(<span style="color: #8b2252;">"VSWR vs. frequency (MHz) for 50 ohm system"</span>, va=<span style="color: #8b2252;">'bottom'</span>)

    plt.savefig(<span style="color: #8b2252;">'../images/monopole_radials_vswr.png'</span>)
    plt.gcf().clear()
</pre>
</div>

<p>
The plot in figure <a href="#monopole_radials_vswr">monopole_radials_vswr</a> shows the response of the optimised antenna across the Airband.
</p>

<figure>
  <img src="{{ site.url }}/assets/monopole_radials_vswr.png" alt="VSWR for 50 ohm system" width="75%">  
  <figcaption>VSWR for 50 ohm system</figcaption>
</figure>


<div id="fig:monopole_radials_vswr" class="figure">
<p><img src="../images/monopole_radials_vswr.png" alt="monopole_radials_vswr.png" />
</p>
<p><span class="figure-number">Figure 4:</span> VSWR for 50 ohm system</p>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Performance sensitivity to realised length</h2>
<div class="outline-text-2" id="text-5">
<p>
For a real-world antenna with construction defects, what is the effect on antenna impedance of the driven element and radials having lengths that deviate from the ideal computed value?  We attempt to compute the partial derivative of \(Z\) with respect to \(l_d\) by taking finite differences around the optimised value of \(l_d\) and estimate our construction tolerance \(\sigma l = 0.01\).  For some small \(h\) we have
</p>

\begin{equation}
\frac{\partial Z}{\partial l_d} \approx \frac{Z(l_d + h) - Z(l_d - h)}{2h}
\end{equation}


<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-compute-dzdl_e"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">compute_dz_dl_e</span>(base, length, r_w, radial_len,
                    radial_offset, n_radials, theta_radial,
                    h):

    <span style="color: #a0522d;">z_n</span> = []
    <span style="color: #a020f0;">for</span> k <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(2):

        <span style="color: #a0522d;">context</span>, <span style="color: #a0522d;">solid_geom</span> = geometry(base, length + ((-1) ** (k + 1) * h),
                                       r_w, radial_len, radial_offset,
                                       n_radials, theta_radial,
                                       N_SEGMENTS,
                                       construct_nec_context=<span style="color: #008b8b;">True</span>,
                                       construct_solid_geom=<span style="color: #008b8b;">False</span>)


        set_frequency(context, FREQ)
        set_excitation(context)
        context.xq_card(0) <span style="color: #b22222;"># </span><span style="color: #b22222;">Execute simulation</span>

        <span style="color: #a0522d;">ip</span> = context.get_input_parameters(0)
        <span style="color: #a0522d;">z</span> = ip.get_impedance()

        z_n.append(z)
        <span style="color: #a020f0;">print</span>(z)

    <span style="color: #a0522d;">partial_z_l_e</span> = (z_n[0] - z_n[1]) / (2 * h)

    <span style="color: #a020f0;">return</span> partial_z_l_e
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Performance sensitivity to realised length</h2>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Compute antenna performance sensitivity (bandwith) to wire thickness</h2>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Compute a suitable bandpass impedance matching network</h2>
<div class="outline-text-2" id="text-8">
<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-compute-matching-network"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">compute_bp_matching_network</span>(z0, zl):
    <span style="color: #a020f0;">return</span> 0.0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Investigate sensitivity to circularly polarised incident radiation</h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">

<pre class="src src-python" id="monopoleradials-main"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">main</span>():

    <span style="color: #a0522d;">parser</span> = ArgumentParser(description=<span style="color: #8b2252;">"Optimise monopole and compute matching network."</span>)
    <span style="color: #a0522d;">args</span> = parser.parse_args()

    base, length, r_w, radial_len, \
        <span style="color: #a0522d;">radial_offset</span>, <span style="color: #a0522d;">n_radials</span>, <span style="color: #a0522d;">theta_radial</span> = optimise_antenna()

    <span style="color: #b22222;"># </span><span style="color: #b22222;">base = 0.007</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">length = 0.63</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">radial_len = 0.6</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">radial_offset = 0.0</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">n_radials = 4</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">theta_radial = 45.0</span>
    <span style="color: #b22222;"># </span><span style="color: #b22222;">r_w = R_W</span>

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"\nOptimisation result\n"</span>)
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"final geometry {} {} {} {} {} {} {}"</span>
          .<span style="color: #483d8b;">format</span>(base, length, r_w, radial_len,
                  radial_offset, n_radials, theta_radial))

    <span style="color: #a0522d;">context</span>, <span style="color: #a0522d;">solid_geom</span> = geometry(base, length, r_w, radial_len,
                                   radial_offset, n_radials, theta_radial,
                                   N_SEGMENTS,
                                   construct_nec_context=<span style="color: #008b8b;">True</span>,
                                   construct_solid_geom=<span style="color: #008b8b;">True</span>)

    <span style="color: #a0522d;">out_dir</span> = sys.argv[1] <span style="color: #a020f0;">if</span> <span style="color: #483d8b;">len</span>(sys.argv) &gt; 1 <span style="color: #a020f0;">else</span> os.curdir
    <span style="color: #a0522d;">file_out</span> = os.path.join(out_dir, <span style="color: #8b2252;">'monopoleradials.scad'</span>)
    sp.scad_render_to_file(solid_geom, file_header=<span style="color: #8b2252;">'$fn = {};'</span>.<span style="color: #483d8b;">format</span>(SEGMENTS),
                           include_orig_code=<span style="color: #008b8b;">True</span>)
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"{}: SCAD file written to: \n{}"</span>.<span style="color: #483d8b;">format</span>(__file__, file_out))

    <span style="color: #a0522d;">z</span> = compute_impedance(context, FREQ)

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"Impedance at base={0:.2f}, length={1:.2f}"</span>
          <span style="color: #8b2252;">" : ({2:6.1f},{3:+6.1f}i) Ohms"</span>
          .<span style="color: #483d8b;">format</span>(base, length, z.real, z.imag))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"Reflection coefficient Gamma={0:0.2f}"</span>
          .<span style="color: #483d8b;">format</span>(reflection_coefficient(z, Z0)))
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"VSWR @50 ohm ={0:0.2f}"</span>
          .<span style="color: #483d8b;">format</span>(vswr(z, Z0)))

    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"z: {0}"</span>.<span style="color: #483d8b;">format</span>(z))

    set_frequency(context, FREQ)
    set_excitation(context)
    plot_radiation_pattern(context)
    <span style="color: #b22222;">#</span><span style="color: #b22222;">compute_bp_matching_network(Z0, zl)</span>

    <span style="color: #a0522d;">context</span>, <span style="color: #a0522d;">solid_geom</span> = geometry(base, length, r_w, radial_len,
                                   radial_offset, n_radials, theta_radial,
                                   N_SEGMENTS,
                                   construct_nec_context=<span style="color: #008b8b;">True</span>,
                                   construct_solid_geom=<span style="color: #008b8b;">False</span>)
    <span style="color: #a0522d;">freqs</span>, <span style="color: #a0522d;">vswrs</span> = compute_vswr(context)
    plot_vswr(freqs, vswrs)

    <span style="color: #b22222;"># </span><span style="color: #b22222;">sensitivity to driven element length</span>
    <span style="color: #a0522d;">h</span> = 0.005
    <span style="color: #a0522d;">dz_dl_e</span> = compute_dz_dl_e(base, length, r_w, radial_len,
                              radial_offset, n_radials, theta_radial,
                              h)
    <span style="color: #a020f0;">print</span>(<span style="color: #8b2252;">"dl10: {0}"</span>.<span style="color: #483d8b;">format</span>(dz_dl_e * SIGMA_L))

    <span style="color: #a020f0;">return</span> 0
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh" id="bashrun-monopoleradials">python monopoleradials.py 2&gt;&amp;1
true
</pre>
</div>

<pre class="example">
z_path min=(52.80634378320185-0.6129484587169558j) max=(84.52668723622808+26.65369957814016j)
gamma_path min=0.02789603132986227 max=0.4041803349448599

Optimisation result

final geometry 3.665433178414191e-14 0.702468950751411 0.0005 0.3473645774547176 0.0 4 39.05842183497735
monopoleradials.py: SCAD file written to: 
./monopoleradials.scad
Impedance at base=0.00, length=0.70 : (  52.8,  -0.5i) Ohms
Reflection coefficient Gamma=0.03
VSWR @50 ohm =1.06
z: (52.81836735879712-0.5326700896016593j)
gains_db.shape = (180, 720)
thetas.shape = (180,) [0.0,1.5620236111111114]
phis.shape = (720,) [0.0,6.274273611111111]
gains \in [5.1826184832943545e-06,1.4704535189360104]
THETA.shape = (720, 180)
PHI.shape = (720, 180)
</pre>
</div>
</div>
